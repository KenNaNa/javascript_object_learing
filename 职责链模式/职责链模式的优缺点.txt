13.6 职责链模式的优缺点
前面已经说过，职责链模式的最大优点就是解耦了请求发送者和 N 个接收者之间的复杂关
系，由于不知道链中的哪个节点可以处理你发出的请求，所以你只需把请求传递给第一个节点即
可，如图 13-2 和图 13-3 所示
在手机商城的例子中，本来我们要被迫维护一个充斥着条件分支语句的巨大的函数，在例子
里的购买过程中只打印了一条 log 语句。其实在现实开发中，这里要做更多事情，比如根据订单
种类弹出不同的浮层提示、渲染不同的 UI 节点、组合不同的参数发送给不同的 cgi 等。 用了职
责链模式之后，每种订单都有各自的处理函数而互不影响。
其次，使用了职责链模式之后，链中的节点对象可以灵活地拆分重组。增加或者删除一个节
点，或者改变节点在链中的位置都是轻而易举的事情。这一点我们也已经看到，在上面的例子中，
增加一种订单完全不需要改动其他订单函数中的代码。
职责链模式还有一个优点，那就是可以手动指定起始节点，请求并不是非得从链中的第一个
节点开始传递。比如在公交车的例子中，如果我明确在我前面的第一个人不是售票员，那我当然
可以越过他把公交卡递给他前面的人，这样可以减少请求在链中的传递次数，更快地找到合适的
请求接受者。这在普通的条件分支语句下是做不到的，我们没有办法让请求越过某一个 if 判断。
拿代码来证明这一点，假设某一天网站中支付过定金的订单已经全部结束购买流程，我们在
接下来的时间里只需要处理普通购买订单，所以我们可以直接把请求交给普通购买订单节点：
orderNormal.passRequest( 1, false, 500 ); // 普通购买, 无优惠券
如果运用得当，职责链模式可以很好地帮助我们组织代码，但这种模式也并非没有弊端，首
先我们不能保证某个请求一定会被链中的节点处理。比如在期末考试的例子中，小纸条上的题目
也许没有任何一个同学知道如何解答，此时的请求就得不到答复，而是径直从链尾离开，或者抛
出一个错误异常。在这种情况下，我们可以在链尾增加一个保底的接受者节点来处理这种即将离
开链尾的请求。
另外，职责链模式使得程序中多了一些节点对象，可能在某一次的请求传递过程中，大部分
节点并没有起到实质性的作用，它们的作用仅仅是让请求传递下去，从性能方面考虑，我们要避
免过长的职责链带来的性能损耗。