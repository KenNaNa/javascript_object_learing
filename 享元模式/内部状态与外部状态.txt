2.1 节的这个例子便是享元模式的雏形，享元模式要求将对象的属性划分为内部状态与外部
状态（状态在这里通常指属性）。享元模式的目标是尽量减少共享对象的数量，关于如何划分内
部状态和外部状态，下面的几条经验提供了一些指引。

 内部状态存储于对象内部。
 内部状态可以被一些对象共享。
 内部状态独立于具体的场景，通常不会改变。
 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享


这样一来，我们便可以把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态
可以从对象身上剥离出来，并储存在外部。
剥离了外部状态的对象成为共享对象，外部状态在必要时被传入共享对象来组装成一个完整
的对象。虽然组装外部状态成为一个完整对象的过程需要花费一定的时间，但却可以大大减少系
统中的对象数量，相比之下，这点时间或许是微不足道的。因此，享元模式是一种用时间换空间
的优化模式。
在上面的例子中，性别是内部状态，内衣是外部状态，通过区分这两种状态，大大减少了系
统中的对象数量。通常来讲，内部状态有多少种组合，系统中便最多存在多少个对象，因为性别
通常只有男女两种，所以该内衣厂商最多只需要 2 个对象。
使用享元模式的关键是如何区别内部状态和外部状态。可以被对象共享的属性通常被划分为
内部状态，如同不管什么样式的衣服，都可以按照性别不同，穿在同一个男模特或者女模特身上，
模特的性别就可以作为内部状态储存在共享对象的内部。而外部状态取决于具体的场景，并根据
场景而变化，就像例子中每件衣服都是不同的，它们不能被一些对象共享，因此只能被划分为外
部状态。

12.3 享元模式的通用结构
12.1 节的示例初步展示了享元模式的威力，但这还不是一个完整的享元模式，在这个例子中
还存在以下两个问题。
 我们通过构造函数显式 new 出了男女两个 model 对象，在其他系统中，也许并不是一开始
就需要所有的共享对象。
 给 model 对象手动设置了 underwear 外部状态，在更复杂的系统中，这不是一个最好的方
式，因为外部状态可能会相当复杂，它们与共享对象的联系会变得困难。
我们通过一个对象工厂来解决第一个问题，只有当某种共享对象被真正需要时，它才从工厂
中被创建出来。对于第二个问题，可以用一个管理器来记录对象相关的外部状态，使这些外部状
态通过某个钩子和共享对象联系起来。


在微云上传模块的开发中，我曾经经历过对象爆炸的问题。微云的文件上传功能虽然可以选
择依照队列，一个一个地排队上传，但也支持同时选择 2000 个文件。每一个文件都对应着一个
JavaScript 上传对象的创建，在第一版开发中，的确往程序里同时 new 了 2000 个 upload 对象，结
果可想而知， Chrome 中还勉强能够支撑， IE 下直接进入假死状态。
微云支持好几种上传方式，比如浏览器插件、 Flash 和表单上传等，为了简化例子，我们先
假设只有插件和 Flash 这两种。不论是插件上传，还是 Flash 上传，原理都是一样的，当用户选
择了文件之后，插件和 Flash 都会通知调用 Window 下的一个全局 JavaScript 函数，它的名字是
startUpload，用户选择的文件列表被组合成一个数组 files 塞进该函数的参数列表里