从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象，
一种方法是先指定它的类型，然后通过类来创建这个对象。原型模式选择了另外一种方式，我们
不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。
既然原型模式是通过克隆来创建对象的，那么很自然地会想到，如果需要一个跟某个对象一
模一样的对象，就可以使用原型模式。
假设我们在编写一个飞机大战的网页游戏。某种飞机拥有分身技能，当它使用分身技能的时
候，要在页面中创建一些跟它一模一样的飞机。如果不使用原型模式，那么在创建分身之前，无
疑必须先保存该飞机的当前血量、炮弹等级、防御等级等信息，随后将这些信息设置到新创建的
飞机上面，这样才能得到一架一模一样的新飞机。
如果使用原型模式，我们只需要调用负责克隆的方法，便能完成同样的功能。
原型模式的实现关键，是语言本身是否提供了clone方法。ECMAScript 5提供了Object.create
方法，可以用来克隆对象

所有的数据都是对象
要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。
对象会记住它的原型。
如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。


1. 所有的数据都是对象
JavaScript 在设计的时候，模仿 Java 引入了两套类型机制：基本类型和对象类型。基本类型
包括 undefined、number、boolean、string、function、object。从现在看来，这并不是一个好的
想法。
按照 JavaScript 设计者的本意，除了 undefined 之外，一切都应是对象。为了实现这一目标，
number、boolean、string 这几种基本类型数据也可以通过“包装类”的方式变成对象类型数据来
处理。
我们不能说在 JavaScript 中所有的数据都是对象，但可以说绝大部分数据都是对象。那么相
信在 JavaScript 中也一定会有一个根对象存在，这些对象追根溯源都来源于这个根对象。
事实上，JavaScript 中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的
对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的，
Object.prototype 对象就是它们的原型

在 Io 语言中，克隆一个对象的动作非常明显，我们可以在代码中清晰地看到 clone 的过程
Dog := Animal clone
但在 JavaScript 语言里，我们并不需要关心克隆的细节，因为这是引擎内部负责实现的。我
们所需要做的只是显式地调用 var obj1 = new Object()或者 var obj2 = {}。此时，引擎内部会从
Object.prototype 上面克隆一个对象出来，我们最终得到的就是这个对象


3. 对象会记住它的原型
如果请求可以在一个链条中依次往后传递，那么每个节点都必须知道它的下一个节点。同理，
要完成 Io语言或者 JavaScript语言中的原型链查找机制，每个对象至少应该先记住它自己的原型。
目前我们一直在讨论“对象的原型”，就 JavaScript 的真正实现来说，其实并不能说对象有
原型，而只能说对象的构造器有原型。对于“对象把请求委托给它自己的原型”这句话，更好
的说法是对象把请求委托给它的构造器的原型。那么对象如何把请求顺利地转交给它的构造器
的原型呢？
JavaScript 给对象提供了一个名为__proto__的隐藏属性，某个对象的__proto__属性默认会指
向它的构造器的原型对象，即{Constructor}.prototype。在一些浏览器中，__proto__被公开出来，
4. 如果对象无法响应某个请求，它会把这个请求委托给它的构造器的原型
这条规则即是原型继承的精髓所在。从对 Io 语言的学习中，我们已经了解到，当一个对象
无法响应某个请求的时候，它会顺着原型链把请求传递下去，直到遇到一个可以处理该请求的对
象为止。
图灵社区会员 轩辕 专享 尊重版权
1.4 原型模式和基于原型继承的 JavaScript 对象系统 21
1
2
3
4
5
13
6
7
8
9
10
11
JavaScript 的克隆跟 Io 语言还有点不一样，Io 中每个对象都可以作为原型被克隆，当 Animal
对象克隆自 Object 对象，Dog 对象又克隆自 Animal 对象时，便形成了一条天然的原型链，如图
1-3 所示。
图 1-3
而在 JavaScript 中，每个对象都是从 Object.prototype 对象克隆而来的，如果是这样的话，
我们只能得到单一的继承关系，即每个对象都继承自 Object.prototype 对象，这样的对象系统显
然是非常受限的。
实际上，虽然 JavaScript 的对象最初都是由 Object.prototype 对象克隆而来的，但对象构造
器的原型并不仅限于 Object.prototype 上，而是可以动态指向其他对象。这样一来，当对象 a 需
要借用对象 b 的能力时，可以有选择性地把对象 a 的构造器的原型指向对象 b，从而达到继承的
效果。下面的代码是我们最常用的原型继承方式：
var obj = { name: 'sven' };
var A = function(){};
A.prototype = obj;
var a = new A();
console.log( a.name ); // 输出：sven
我们来看看执行这段代码的时候，引擎做了哪些事情。
 首先，尝试遍历对象 a 中的所有属性，但没有找到 name 这个属性。
 查找 name 属性的这个请求被委托给对象 a 的构造器的原型，它被 a.__proto__ 记录着并且
指向 A.prototype，而 A.prototype 被设置为对象 obj。
 在对象 obj 中找到了 name 属性，并返回它的值。
当我们期望得到一个“类”继承自另外一个“类”的效果时，往往会用下面的代码来模拟实现：
var A = function(){};
A.prototype = { name: 'sven' };
var B = function(){};
B.prototype = new A();
var b = new B();
console.log( b.name ); // 输出：sven
再看这段代码执行的时候，引擎做了什么事情。
 首先，尝试遍历对象 b 中的所有属性，但没有找到 name 这个属性。
图灵社区会员 轩辕 专享 尊重版权
22 第 1 章 面向对象的 JavaScript
 查找 name 属性的请求被委托给对象 b 的构造器的原型，它被 b.__proto__ 记录着并且指向
B.prototype，而 B.prototype 被设置为一个通过 new A()创建出来的对象。
 在该对象中依然没有找到 name 属性，于是请求被继续委托给这个对象构造器的原型
A.prototype。
 在 A.prototype 中找到了 name 属性，并返回它的值。
和把 B.prototype 直接指向一个字面量对象相比，通过 B.prototype = new A()形成的原型链比
之前多了一层。但二者之间没有本质上的区别，都是将对象构造器的原型指向另外一个对象，继
承总是发生在对象和对象之间。
最后还要留意一点，原型链并不是无限长的。现在我们尝试访问对象 a 的 address 属性。而
对象 b 和它构造器的原型上都没有 address 属性，那么这个请求会被最终传递到哪里呢？
实际上，当请求达到 A.prototype，并且在 A.prototype 中也没有找到 address 属性的时候，
请求会被传递给 A.prototype 的构造器原型 Object.prototype，显然 Object.prototype 中也没有
address 属性，但 Object.prototype 的原型是 null，说明这时候原型链的后面已经没有别的节点了。
所以该次请求就到此打住，a.address 返回 undefined。
a.address // 输出：undefined 